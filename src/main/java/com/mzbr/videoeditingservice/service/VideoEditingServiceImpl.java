package com.mzbr.videoeditingservice.service;import java.io.BufferedWriter;import java.io.File;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;import java.util.ArrayList;import java.util.List;import java.util.StringJoiner;import java.util.concurrent.TimeUnit;import java.util.stream.Collectors;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import org.springframework.stereotype.Service;import com.github.kokorin.jaffree.StreamType;import com.github.kokorin.jaffree.ffmpeg.*;import com.mzbr.videoeditingservice.model.Clip;import com.mzbr.videoeditingservice.model.VideoEntity;@Servicepublic class VideoEditingServiceImpl implements VideoEditingService {	@Autowired	private ResourceLoader resourceLoader;	@Override	public String processVideo(VideoEntity videoEntity, String outPutPath) {		FFmpeg ffmpeg = FFmpeg.atPath();		Path outputPath = Paths.get("output.mp4");		List<Input> inputs = new ArrayList<>();		StringJoiner filterJoiner = new StringJoiner(";");		int index = 0;		int pos = 0;		for (Clip clip : videoEntity.getClips()) {			// ... 기존 코드를 사용하여 각 클립의 'file' 변수를 생성합니다 ...			Resource resource = resourceLoader.getResource("classpath:" + clip.getUrl());			File file = null;			try {				file = File.createTempFile(clip.getUrl(), ".mp4");			} catch (IOException e) {				throw new RuntimeException(e);			}			try {				Files.copy(resource.getInputStream(), file.toPath(), StandardCopyOption.REPLACE_EXISTING);			} catch (IOException e) {				throw new RuntimeException(e);			}			inputs.add(UrlInput.fromPath(file.toPath()));			String baseFilter = String.format("[%d:v]trim=start=%.2f:duration=%.2f,setpts=PTS-STARTPTS", index,				(double)pos / 1000, (double)clip.getDurationTime() / 1000);			if (clip.getCrop() != null) {				Integer newWidth = (int)(clip.getWidth() / clip.getCrop().getZoomFactor());				Integer newHeight = (int)(clip.getHeight() / clip.getCrop().getZoomFactor());				baseFilter += String.format(",scale=%d:%d,crop=%d:%d:%d:%d",					newWidth, newHeight, newWidth, newHeight, clip.getCrop().getStartX(), clip.getCrop().getStartY());			}			baseFilter+=",scale=1920:1080";			filterJoiner.add(baseFilter + String.format("[v%d]", index));			index++;			pos += clip.getDurationTime();		}		String finalFilter = filterJoiner.toString() + String.format(";[v0][v1]concat=n=%d:v=1:a=0[outv]", index);		System.out.println("!!!!!!!!!!!!!!!!!!!!!!");		System.out.println(finalFilter);		// Inputs 추가		for (Input input : inputs) {			ffmpeg.addInput(input);		}		// Output 설정 및 필터 적용		ffmpeg.addOutput(UrlOutput.toPath(outputPath)				.addArguments("-filter_complex", finalFilter)				.addArguments("-map", "[outv]"))			.execute();		return null;	}}