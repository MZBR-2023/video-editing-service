package com.mzbr.videoeditingservice.service;import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.StandardCopyOption;import java.util.ArrayList;import java.util.List;import java.util.StringJoiner;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import org.springframework.stereotype.Service;import com.github.kokorin.jaffree.ffmpeg.*;import com.mzbr.videoeditingservice.model.Audio;import com.mzbr.videoeditingservice.model.Clip;import com.mzbr.videoeditingservice.model.VideoEntity;@Servicepublic class VideoEditingServiceImpl implements VideoEditingService {	private final ResourceLoader resourceLoader;	@Autowired	public VideoEditingServiceImpl(ResourceLoader resourceLoader) {		this.resourceLoader = resourceLoader;	}	@Override	public String processVideo(VideoEntity videoEntity, String outPutPath) {		return null;	}	@Override	public void localVideoProcess(VideoEntity videoEntity, int width, int height) throws IOException {		String outputPath = videoEntity.getVideoUuid() + "[%03d].mov";		FFmpeg fFmpeg = FFmpeg.atPath();		StringBuilder filter = new StringBuilder();		List<Input> inputs = prepareVideoInputsByLocal(videoEntity.getClips());		filter.append(generateVideoCropAndLayoutFilter(videoEntity.getClips(), width, height)).append(";");		filter.append(generateAudioVolumeFilter(videoEntity.getClips())).append(";");		filter.append(generateConcatVideoFilter(videoEntity.getClips().size()));		inputs.forEach(input -> fFmpeg.addInput(input));		fFmpeg.addOutput(UrlOutput.toPath(Path.of(outputPath))				.addArguments("-filter_complex", filter.toString())				.addArguments("-r", "30")				.addArguments("-g", "5")				.addArguments("-f", "segment")				.addArguments("-segment_time", "5")				.addArguments("-segment_time_delta","0.05")				.addArguments("-reset_timestamps", "1")				.addArguments("-map", "[outv]")				.addArguments("-map", "[outa]"))			.execute();	}	@Override	public List<Input> prepareVideoInputs(List<Clip> clips) {		List<Input> inputs = new ArrayList<>();		return null;	}	public List<Input> prepareVideoInputsByLocal(List<Clip> clips) throws IOException {		List<Input> inputs = new ArrayList<>();		try {			for (Clip clip : clips) {				Resource resource = resourceLoader.getResource("classpath:" + clip.getUrl());				File file = File.createTempFile(clip.getUrl(), ".mp4");				Files.copy(resource.getInputStream(), file.toPath(), StandardCopyOption.REPLACE_EXISTING);				inputs.add(UrlInput.fromPath(file.toPath()));			}		} catch (IOException e) {			throw new IOException("파일을 찾을 수 없습니다.");		}		return inputs;	}	@Override	public String generateVideoCropAndLayoutFilter(List<Clip> clips, Integer scaleX, Integer scaleY) {		StringJoiner filterJoiner = new StringJoiner(";");		int pos = 0;		for (int i = 0; i < clips.size(); i++) {			Clip clip = clips.get(i);			StringBuilder baseFilter = new StringBuilder();			// baseFilter.append(String.format("[%d:v]trim=start=0:duration=%.2f,setpts=PTS-STARTPTS", i,			// 	// (double)pos / 1000,			// 	(double)clip.getDurationTime() / 1000));			baseFilter.append(String.format("[%d:v]setpts=PTS-STARTPTS", i));			if (clip.getCrop() != null) {				Integer newWidth = (int)(clip.getWidth() / clip.getCrop().getZoomFactor());				Integer newHeight = (int)(clip.getHeight() / clip.getCrop().getZoomFactor());				baseFilter.append(String.format(",crop=%d:%d:%d:%d",					newWidth, newHeight, clip.getCrop().getStartX(), clip.getCrop().getStartY()));			}			baseFilter.append(String.format(",scale=%d:%d", scaleX, scaleY));			filterJoiner.add(baseFilter + String.format("[v%d]", i));			pos += clip.getDurationTime();		}		return filterJoiner.toString();	}	@Override	public String generateAudioVolumeFilter(List<Clip> clips) {		StringJoiner filterJoiner = new StringJoiner(";");		for (int i = 0; i < clips.size(); i++) {			Clip clip = clips.get(i);			if (clip.getVolume() != null) { // 불륨 조정이 필요한 경우에만 필터를 추가합니다.				filterJoiner.add(String.format("[%d:a]volume=%.2f[a%d]", i, clip.getVolume(), i));			}		}		return filterJoiner.toString();	}	@Override	public String generateConcatVideoFilter(Integer clipCount) {		StringBuilder filterBuilder = new StringBuilder();		for (int i = 0; i < clipCount; i++) {			filterBuilder.append(String.format("[v%d][a%d]", i, i));		}		filterBuilder.append(String.format("concat=n=%d:v=1:a=1[outv][outa]", clipCount));		return filterBuilder.toString();	}	@Override	public Input insertAudioToVideo(Audio audio) {		return null;	}	@Override	public List<String> splitVideoIntoSegments(FFmpeg fFmpeg, int perSegmentSec) {		return null;	}	@Override	public void uploadTempFileToS3(List<String> fileLocations) {	}	@Override	public void deleteTemporaryFile(List<String> fileLocations) {	}}